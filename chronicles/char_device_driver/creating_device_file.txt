Creating the Device Files:
==========================

Dynamic Device File Creation in Linux:
**************************************
1. In Linux, the Device files are created dynamically i.e. on-demand.
2. The 'udev' (short for User-space /dev) is the Device manager for Linux Kernel. It is used to dynamically create/remove the Device files as the HW are added/removed.
	1) The Kernel detects a Device getting added/removed/state-changed (hot plug-in events) and generates a 'uevent'.
	2) The 'udevd' is the part of the 'udev' system which handles these 'uevent' to populate/clear the "/dev" directory with the Device files dynamically.
	3) The 'udev' relies heavily on the "/sys/class" directory to gather information about the Devices.
	4) For the 'class' based Devices, the "/sys/class/*" entries are read.
	5) The 'udev' matches the rules based on the values in "/sys" attributes.
3. The 'udevd' is the User-space daemon for managing the Device events on the Linux Kernel. It is also known as 'systemd-udevd' in the modern systems.
	1) It is always running in the background and listens to the 'uevent' generated by the Kernel (either through the hot plug-in events or the Kernel modules).
	2) It parses the Device information such as Vendor ID, Product ID, Serial-number etc.
	3) It applies the 'udev rules' to manage the Device nodes, permissions, names, and symbolic links.
	4) It creates/removes the Device files in "/dev".
	5) It sets permissions, ownership and creates the symbolic links for easier Device identification.
4. The "/sys/class" is a part of the VFS provided by the Kernel.
	1) Each sub-directory in the "/sys/class" corresponds to a Device class like 'block', 'net', 'tty' etc.
	2) These sub-directories contain symbolic links to the actual Device objects in "/sys/devices".
	3) These Device objects contain attributes like 'dev', 'subsystem', 'device', 'events' etc.
5. The 'udev' rules and configurations are placed in the following location:
	1) /etc/udev/rules.d/ => The Admin-defined rules.
	2) /lib/udev/rules.d/ => The System-supplied rules.
	3) /etc/udev/udev.conf => The main configuration file.
6. The Device Driver needs to ensure that any Major and Minor numbers assigned to a Device controlled by the Driver should be exported to the User-space through the "/sys".
7. The Kernel API function to export all the information regarding the Device is:
        => struct device *device_create(const struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...);
        ---> 'class' is the Pointer to the Device class. It is created with the function 'class_create'.
	---> 'parent' is the Pointer to the Parent Device. It can be NULL.
	---> 'devt' is the Device number.
	---> 'drvdata' is the Driver-specific data associated with the Device.
	---> 'fmt' is the format String containing the Device name.
	---> The return value for the function: Pointer to the 'struct device' is Success and ERR_PTR is Failure.
	---> It is defined in the Header file <linux/device.h>.
8. The Kernel API function to create a Device class under the "/sys/class" is:
	=> struct class * __must_check class_create(const char *name);
	---> 'name' is the name of the class. It appears with the same name in the "/sys/class".
	---> The return value for the function: Pointer to the 'struct class' is Success and ERR_PTR is Failure.
	---> It is defined in the Header file <linux/device/class.h>.
9. The 'class_create' function creates a directory 'class_name' in the "/sys/class" and the 'device_create' function creates a sub-directory in the "/sys/class/class_name".
10. The meaning of all this information exported to the User-space is that the "/sys/class" is available in the User-space.
11. The 'udev' relies on this Device information being exported from the "/sys" to create the appropriate Device file in the "/dev".
