Important Data-types for File Operations:
=========================================

Structure 'file_operations':
****************************
1. The Structure Data-type 'file_operations' contains the collection of Pointers to functions defined by the Driver that perform various operations on the Device.
2. It is defined in the Header file <linux/fs.h>.
3. The field 'struct module *owner' is the first field of the 'file_operations'.
	1) The Structure Data-type 'struct module' defined in the Header file <linux/module.h>.
	2) It is not an operation but the Pointer to the Module that owns the Structure.
	3) It is used to prevent the Module from being unloaded while the Device is being used.
	4) It is simply initialized to the value 'THIS_MODULE'.
4. The field 'llseek' is provided to contain the Driver function to allow for seeking within the file.
	1) When the User-space uses 'lseek' System-call on the Device file in "/dev", this function handles the logic for updating the file position.
	2) It manages the 64-bit extended file Pointer for the precise file positioning based on the provided offset and starting point in 'lseek' call.
	3) The 'llseek' function prototype is:
		=> loff_t (*llseek) (struct file *, loff_t, int);
		---> The new file position is returned from the function as a 'long offset' that is 64-bit wide. The negative values represent Errors.
	4) If this is NULL, the 'lseek' System-call will modify the file position in potentially unpredictable ways.
5. The field 'read' is provided to contain the Driver function to retrieve data from the Device.
	1) When the User-space uses 'read' System-call on the Device file in "/dev", this function handles the read operation.
	2) It handles the low-level details of accessing the registers, managing the Interrupts and buffering the data.
		=> The requested data is copied from the Device's Memory into a Buffer in the Kernel Memory.
		=> The Driver then uses the "copy_to_user" function to copy the data from the Kernel-space to the User-space.
			---> unsigned long copy_to_user(void *to, const void *from, unsigned long count);
	3) The 'read' function prototype is:
		=> ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
		---> The return value is of 'signed size' type. A non-negative return value represents the number of data bytes read successfully.
		---> The negative value represent Errors. If some data is read and then the Error occurs, the return value is less than the requested data.
	4) If this is NULL, the 'read' System-call fails with an 'invalid argument' Error (-EINVAL).
6. The field 'write' is provied to contain the Driver function to send data to the Device.
	1) When the User-space uses 'write' System-call on the Device file in "/dev", this function handles the write operation.
	2) It handles the low-level details of accessing the registers, managing the Interrupts and buffering the data.
		=> The Driver uses the "copy_from_user" function to copy the data from the User-space to the Kernel-space.
			---> unsigned long copy_from_user(void *to, const void *from, unsigned long count);
		=> The Driver translates the data and instructions into a format that the Device understands.
		=> The Driver initiates the write operation such as writing to Memory, sending data to a Peripheral or controlling a HW function.
	3) The 'write' function prototype is:
		=> ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
		---> The return value is of 'signed size' type. A non-negative return value represents the number of data bytes written successfully.
		---> The negative value represent Errors. If some data is written and then the Error occurs, the return value is less than the sent data.
	4) If this is NULL, the 'write' System-call fails with an 'invalid argument' Error (-EINVAL).
7. The field 'poll' is provided to contain the Driver function to poll the Device for the requested I/O operations.
	1) When the User-space uses 'poll', 'epoll' or 'select' System-calls on the Device file in "/dev", this function handles the polling operation.
		=> It checks whether the Device is ready for any of the requested I/O operations (read, write, or exception).
		=> If the Device is not ready, it adds wait queues to the 'poll_table_struct' for those events.
		=> It provides the Kernel with information that can be used to put the calling process to sleep until I/O operations becomes possible.
	2) It should return a bitmask of event flags indicating whether the non-blocking I/O operations are possible currently.
	3) The 'poll' function prototype is:
		=> __poll_t (*poll) (struct file *, struct poll_table_struct *);
		---> The return type of the bitmask of event flags is '__poll_t' indicating the readiness of the Device for the I/O operations.
	4) If this is NULL, the Device is assumed to be always readable and writable without blocking.
8. The field 'unlocked_ioctl' is provided to contain the Driver function to issue Device-specific commands.
	1) When the User-space uses 'ioctl' System-call on the Device file in "/dev", this function handles the way to provide I/O and control operations.
		=> The 'ioctl' call used to run under the Big Kernel Lock (BKL). It used to lock the whole Kernel during it's operation.
		=> The usage of BKL made it possible for the long-running 'ioctl' calls to create long latencies for unrelated processes.
		=> The 'ioctl' call is a powerful mechanism for User-space applications to control the behavior of Devices.
		=> However, it was seen as a completely uncontrolled entry point to the Kernel-space.
	2) The new way to implement this function is introduced which doesn't lock the Kernel during the operation.
		=> The request code (an integer) is passed that determines the specific action to be performed on the Device.
	3) The 'unlocked_ioctl' function prototype is:
		=> long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
		---> The return value if non-negative represents Success. The negative value represent Errors.
	4) If this is NULL, the 'ioctl' call returns an Error for any request (that is not pre-defined) i.e. no such Device 'ioctl' (-ENOTTY).
9. The field 'compat_ioctl' is provided to contain the Driver function to maintain compatiblity to 'ioctl' calls.
	1) It is unrelated to 'unlocked_ioctl' function implementation.
	2) The purpose of this implementation is to allow 32-bit User-space applications to generate 'ioctl' calls on 64-bit Kernel.
		=> It should do the required conversion of the arguments to the native Data-types and carry out the request.
	3) The 'compat_ioctl' function prototype is:
		=> long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
	4) If this is NULL, the Data Structures must be compatible for both 32-bit and 64-bit Kernels and the 'unlocked_ioctl' implementation must be used.

x. The field 'open' is provided to contain the Driver function to perform any initializations in preparation for the later operations.
	1) When the User-space uses 'open' System-call on the Device file in "/dev", it is transferred to the Kernel.
	2) The Kernel VFS processes receives the 'open' System-call and finds the appropriate Driver implementation for it's execution.
		=> The VFS performs the initialization of a Structure Data-type 'struct file' and links it to the corresponding Structure Data-type 'struct inode'.
		=> The VFS then calls this 'open' function (pointing to the associated Driver 'open' implementation) to perform the opening on the Device.
		=> On successful 'open', the VFS assigns a file descriptor and returns it to the User-space.
	3) The 'open' function prototype is:
		=> int (*open) (struct inode *, struct file *);
	4) If this is NULL, the 'open' System-call always succeeds but the Driver isnâ€™t notified.
