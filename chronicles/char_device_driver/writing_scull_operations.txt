Important File Operations for the scull:
========================================

open Function:
**************
1. The 'open' function is provided for a Driver to do any initialization in preparation for later operations.
2. Generally, it performs the following tasks:
	1) Check for the Device-specific errors such as 'device-not-ready' or 'similar hardware problems' etc.
	2) Initialize the Device if it is being opened for the first time.
	3) Check the permissions (O_RDONLY, O_WRONLY, O_RDWR etc) for the file being opened.
	4) Identify the Minor number and update the 'f_op' Pointer, if necessary.
	5) Allocate and fill any Data Structure to be put in the 'private_data' field.
	6) Update the 'f_pos' field, if necessary.
	7) Increment the Usage-count.
3. The 'open' System-call flow is as follows:
	1) The User-space executes 'open' call.
	2) The glibc wrapper calls the 'syscall' wrapper.
	3) The Kernel-space calls the System-call Handler 'sys_open' / 'sys_openat'.
	4) The Handler calls the Kernel functions:
		=> do_sys_open() / do_sys_openat2()
			|
			V
		=> do_filp_open() ---> The 'struct file' is created.
			|
                        V
		=> path_openat() ---> The core path resolution logic.
			|
                        V
		=> do_open()
			|
                        V
		=> vfs_open()
			|
                        V
		=> do_dentry_open() ---> The 'struct file' fields are initialized and the field 'f_op' is initialized with the field 'i_fop'.
			|
                        V
		=> chrdev_open() ---> The 'struct cdev' is retrieved based on the registered Device number and the field 'f_op' is initialized with the field 'ops'.
			|
                        V
		=> filp->f_op->open() ---> The Driver's 'open' function is called.
			|
			V
		=> do_sys_open() / do_sys_openat2() ---> The 'fd' for the open file is returned to the User-space.
	5) The Kernel functions are defined in the following files:
		=> <fs/open.c>
		=> <fs/namei.c>
		=> <fs/char_dev.c>
4. The brief explanation for the above flow is:
	1) Whenever a Device file is created, the 'init_special_inode' is called to initialize the inode as follows:
		=> The field 'i_fop' is initialized with a default file operation implementation based on the 'mode' argument i.e Char/Block/FIFO Device.
		=> The field 'i_rdev' is initialized with the Device number 'rdev' argument of the newly created Device file.
	2) The dummy default file operation for the Character Device is defined in the <fs/char_dev.c> file as follows:
		=> const struct file_operations def_chr_fops = {
			   .open = chrdev_open,
			   .llseek = noop_llseek,
		   };
	3) The 'do_filp_open' function creates the 'file' Structure to represent the open Device file.
	4) The 'do_dentry_open' function calls the default 'def_chr_fops' file operation which in turn calls the 'chrdev_open' open operation implementation.
	5) The 'chrdev_open' function is executed as follows:
		=> The field 'i_cdev' is NULL as 'init_special_inode' function doesn't initializes this field of the inode.
		=> The 'kobj_lookup' function is used to find the 'kobj' field of the 'cdev' Structure for the Device using the Device number 'i_rdev' argument in the 'cdev_map'.
		=> The 'container_of' Macro is used to retrieve a Pointer to the 'cdev' Structure using the 'kobj' field Pointer.
		=> This 'cdev' Structure is the one that gets added in the 'cdev_add' function while registering the Device.
		=> The 'i_cdev' field is then initialized with the 'cdev' Structure of the Device.
		=> The 'fops' is then initialized with the 'cdev' Structure field 'ops'. This is the file operations that can be performed on the Device.
		=> The 'replace_fops' function is used to replace the default file operations with the actual Driver file operations.
		=> Then, the Driver 'open' function is called to execute the 'open' System-call.
		=> Based on the return values from all the Kernel functions, the 'do_sys_openat2' function returns the file descriptor to the User-space.
5. The Minor number plays an important role in the Device being opened.
	1) The Kernel doesn't use the Minor number of the Device, so the Driver can use it at will.
	2) The different Minor numbers are used to access different Devices or to open the same Device in different ways.
6. The Driver never knows the name of the Device being opened. It just knows the Device number.
	1) The same Device can be provided new names by aliasing for convinience.
	2) If there are 2 Device files with the same Device numbers, they cannot be differentiated.
	3) The same effect can be obtained using a symbolic or hard link and the preferred way to implement aliasing is creating a symbolic link to the Device file.
7. The 'open' function prototype is:
	=> int open(struct inode *inode, struct file *filp);
	---> The return value if non-negative represents Success. The negative value represent Errors.
8. The 'open' function can be left empty or not defined i.e. it is optional.
9. The 'cdev' Structure (set up during the Char Device registration in scull) information is needed to identify the Device being opened.
	1) This information is obtained from the 'i_cdev' field of the 'inode' Structure argument.
	2) However, the the desired information here is not the 'cdev' Structure itself but the 'scull_dev' Structure containing it.
	3) The 'container_of' Macro is used to return the Pointer to the required 'scull_dev' Structure.
	=> dev = container_of(inode->i_cdev, struct scull_dev, cdev);
	4) This 'dev' Pointer can then be stored in the 'private_data' field of the 'struct file' Structure.
10. There is no particular Device handling for the scull when opened.
	1) Specifically, there is no such action as 'initializing the Device on first open' because there is no count for the opening in the sculls.
	2) The only real operation performed on the Device is truncating it to a length of 0 when the Device is opened for writing only.
	3) It is performed because by design, overwriting a scull Device with a shorter file results in a shorter Device data area.
	=> if ((filp->f_flags & O_ACCMODE) == O_WRONLY) {
		   scull_trim(dev);
	   }
	4) There is no such operation required if the Device is opened for reading only.

release Function:
*****************
1. The 'release' function is provided for a Driver to reverse the operations done in 'open' function.
2. Generally, it performs the following tasks:
	1) Deallocate any Data Structure that is allocated in the 'private_data' field.
	2) Shut down the Device on last 'close' System-call on the Device file.
3. The Kernel keeps a counter of the number of times a 'struct file' Structure is being used.
	1) Every time a file descriptor is duplicated using the 'dup' and 'fork' System-calls, the counter is incremented.
	2) When a file descriptor is closed, the counter is decremented.
	3) When the counter reaches 0, the 'struct file' Structure is freed from the Memory using the 'release' function.
	4) Therefore, not every 'close' System-call invokes the 'release' function.
	5) The 'release' function is called when all the refrences to an opened file is closed.
	6) The 'f_ref' field of the 'struct file' Structure is used to handle reference counting.
4. The 'close' System-call flow is as follows:
	1) The User-space executes 'open' call.
	2) The glibc wrapper calls the 'syscall' wrapper.
	3) The Kernel-space calls the System-call Handler 'sys_close'.
	4) 4) The Handler calls the Kernel functions:
		=> file_close_fd() ---> The 'struct file' is retrieved.
			|
			V
		=> filp_flush()
			|
			V
		=> fput_close_sync() ---> The logic to synchronously close and release the 'struct file'.
			|
			V
		=> __fput() ---> The last reference of the 'struct file' is released.
			|
			V
		=> filp->f_op->release() ---> The Driver's 'release' function is called.
	5) The Kernel functions are defined in the following files:
		=> <fs/file_table.c>
		=> <fs/open.c>
		=> <fs/file.c>
		=> <include/linux/file_ref.h>
