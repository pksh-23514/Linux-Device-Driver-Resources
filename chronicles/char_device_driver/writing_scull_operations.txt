Important File Operations for the scull:
========================================

open Function:
**************
1. The 'open' function is provided for a Driver to do any initialization in preparation for later operations.
2. Generally, it performs the following tasks:
	1) Check for the Device-specific errors such as 'device-not-ready' or 'similar hardware problems' etc.
	2) Initialize the Device if it is being opened for the first time.
	3) Check the permissions (O_RDONLY, O_WRONLY, O_RDWR etc) for the file being opened.
	4) Identify the Minor number and update the 'f_op' Pointer, if necessary.
	5) Allocate and fill any Data Structure to be put in the 'private_data' field.
	6) Update the 'f_pos' field if necessary.
	7) Increment the Usage-count.
3. The 'open' System-call flow is as follows:
	1) The User-space executes 'open' call.
	2) The glibc wrapper calls the 'syscall' wrapper.
	3) The Kernel-space calls the System-call Handler 'sys_open' / 'sys_openat'.
	4) The Handler calls the Kernel functions:
		=> do_sys_open() / do_sys_openat2()
			|
			V
		=> do_filp_open() ---> The 'struct file' is created.
			|
                        V
		=> path_openat() ---> The core path resolution logic.
			|
                        V
		=> do_open()
			|
                        V
		=> vfs_open()
			|
                        V
		=> do_dentry_open() ---> The 'struct file' fields are initialized and the field 'f_op' is initialized with the field 'i_fop'.
			|
                        V
		=> chrdev_open() ---> The 'struct cdev' is retrieved based on the registered Device number and the field 'f_op' is initialized with the field 'ops'.
			|
                        V
		=> filp->f_op->open() ---> The Driver's 'open' function is called.
			|
			V
		=> do_sys_open() / do_sys_openat2() ---> The 'fd' for the open file is returned to the User-space.
	5) The Kernel functions are defined in the following files:
		=> <fs/open.c>
		=> <fs/namei.c>
		=> <fs/char_dev.c>
4. The brief explanation for the above flow is:
	1) Whenever a Device file is created, the 'init_special_inode' is called to initialize the inode as follows:
		=> The field 'i_fop' is initialized with a default file operation implementation based on the 'mode' argument i.e Char/Block/FIFO Device.
		=> The field 'i_rdev' is initialized with the Device number 'rdev' argument of the newly created Device file.
	2) The dummy default file operation for the Character Device is defined in the <fs/char_dev.c> file as follows:
		=> const struct file_operations def_chr_fops = {
			   .open = chrdev_open,
			   .llseek = noop_llseek,
		   };
	3) The 'do_filp_open' function creates the 'file' Structure to represent the open Device file.
	4) The 'do_dentry_open' function calls the default 'def_chr_fops' file operation which in turn calls the 'chrdev_open' open operation implementation.
	5) The 'chrdev_open' function is executed as follows:
		=> The field 'i_cdev' is NULL as 'init_special_inode' function doesn't initializes this field of the inode.
		=> The 'kobj_lookup' function is used to find the 'kobj' field of the 'cdev' Structure for the Device using the Device number 'i_rdev' argument in the 'cdev_map'.
		=> The 'container_of' Macro is used to retrieve a Pointer to the 'cdev' Structure using the 'kobj' field Pointer.
		=> This 'cdev' Structure is the one that gets added in the 'cdev_add' function while registering the Device.
		=> The 'i_cdev' field is then initialized with the 'cdev' Structure of the Device.
		=> The 'fops' is then initialized with the 'cdev' Structure field 'ops'. This is the file operations that can be performed on the Device.
		=> The 'replace_fops' function is used to replace the default file operations with the actual Driver file operations.
		=> Then, the Driver 'open' function is called to execute the 'open' System-call.
		=> Based on the return values from all the Kernel functions, the 'do_sys_openat2' function returns the file descriptor to the User-space.
5. 
