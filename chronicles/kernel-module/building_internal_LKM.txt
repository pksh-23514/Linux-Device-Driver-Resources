Steps to Build the In-Tree (Internal) LKM:
==========================================

Module addition in Kernel Source Tree:
**************************************
1. The LKM must be added in the Linux Kernel Source Tree and the Build system builds that Module.
2. The path to the Kernel Source shall be the cloned repository of the BBB Linux Kernel (/workdir/linux_source_BBB_ver).
3. The path to include the LKM is (/workdir/linux_source_BBB_ver/drivers/char). A new directory is created to contain the LKM files.

Create Kconfig file for Module:
******************************* 
1. To list the LKM selection in the Kernel menuconfig tool, a Kconfig file is created for the LKM.
2. The Kconfig file describes a series of menu entries, where every line starts with a keyword (except help texts). They are:
	1) config:
		=> This defines a config symbol '<symbol>' and accepts any of above attributes as options.
		---> "config" <symbol>
			<config options>
	2) menuconfig:
		=> It similar to the simple config entry. it also gives a hint to front-end, that all sub-options should be displayed as a separate list of options.
		=> To make sure all the suboptions are really displayed under the menuconfig entry, every item in the list must depend on the menuconfig symbol.
		---> menuconfig M
		     if M
		         config C1
		         config C2
		     endif
		---> menuconfig M
		     config C1
		         depends on M
		     config C2
		         depends on M
	=> choice/endchoice
	=> comment
	=> menu/endmenu
	=> if/endif
	=> source
3. The menu entry can have a number of attributes. However, not all of them are applicable everywhere. They are:
	=> type - Every 'config' option must have a type. The two basic types: 'tristate' and 'string'. The others are based on these 2: 'bool', 'hex' and 'int'.
	=> input prompt - Every menu entry can have at most one prompt used to display. Optional dependencies can be added using 'if'.
		---> "prompt" <prompt> ["if" <expr>]
	=> default value - There can be any number of default values for a 'config' option. However, the first one is active.
		1) Default values are not limited to the menu entry where they are defined. They can be defined somewhere else or overriden by earlier definition.
		2) It is only assigned to the config symbol if no other value was set by the user (via the input prompt above) to override.
		3) Optional dependencies can be added using 'if'.
		4) The default value deliberately defaults to 'n' in order to avoid bloating the build.
		---> "default" <expr> ["if" <expr>]
	=> type definition + default value - This is a shorthand notation for a type definition plus a value. Optional dependencies can be added using 'if'.
		---> "def_bool"/"def_tristate" <expr> ["if" <expr>]
	=> dependencies - The menu entry can have dependencies defined.
		1) If multiple dependencies are defined, they are connected with '&&'.
		2) These are applicable to all other options within this menu entry. They also accept an 'if' expression.
		---> "depends on" <expr>
	=> help - This defines a help text. The end of the help text is determined by the indentation level.
		---> "help" or "---help---"
4. The menu entry can have a number of menu dependencies. They define the visibility of a menu entry and can also reduce the input range of tristate symbols. They are:
	=> <expr> ::= <symbol> - Convert the symbol into an expression. Boolean and tristate symbols are converted to their expression values and other types result in 'n'.
	=> <expr> ::= <symbol> '=' <symbol> - If the values of both symbols are equal, it returns 'y', otherwise 'n'.
	=> <expr> ::= <symbol> '!=' <symbol> - If the values of both symbols are equal, it returns 'n', otherwise 'y'.
	=> <expr> ::= <symbol1> 'X' <symbol2> - Here 'X' can be '<', '>', '<=' or '>='. The comparision if True eturns 'y', otherwise 'n'
	=> <expr> ::= '(' <expr> ')' - Returns the value of the expression. It is used to override precedence.
	=> <expr> ::= '!' <expr> - Returns the result of (2-/expr/).
	=> <expr> ::= <expr> '&&' <expr> - Returns the result of min(/expr/, /expr/).
	=> <expr> ::= <expr> '||' <expr> - Returns the result of max(/expr/, /expr/).
	=> The tristate logic used in the expressions uses one more state than normal boolean logic to express the module state.
	=> An expression can have a value of 'n', 'm' or 'y' (or 0, 1, 2) respectively for calculations.
	=> A menu entry becomes visible when its expression evaluates to 'm' or 'y'.
	=> There are two types of symbols: constant and non-constant symbols.
	=> Non-constant symbols are the most common ones and are defined with the 'config' statement. They are entirely of alphanumeric characters or underscores.
	=> Constant symbols are only part of expressions. They are in single or double quotes. Any other character is allowed in quotes and quotes can be escaped using '\'.
5. The position of a menu entry in the tree (Menu structure) is determined in two ways. They are:
	=> It can be specified explicitly within the 'menu' ... 'endmenu' block. All entries within become a submenu and inherit the dependencies from the menu entry.
		---> menu "prompt"
			     depends on <expr>
		     config <symbol>
		             <config options>
		     endmenu
	=> The other way to generate the menu structure is by analyzing the dependencies. If an entry somehow depends on the previous entry, it can be made a submenu of it.
		1) First, the previous (parent) symbol must be part of the dependency list and then one of these two conditions must be true:
			---> the child entry must become invisible, if the parent is set to 'n'.
			---> the child entry must only be visible, if the parent is visible.
		---> config <symbol1>
                              <config options>
		     config <symbol2>
                              <config options>
		              depends on <symbol1>
